<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>CalculatedVariables</title>
  </head>
  <body>
    <h1> Calculated Variables</h1>
    <br>
    by: Piotr Nikiel, Oct-Nov 2018<br>
    <br>
    <h2>Preface</h2>
    A lot of concepts and work done in context of quasar's
    CalculatedVariables module has been inspired by V.Filimonov's
    "CalculatedItems" concept in the CANopen OPC-UA server.<br>
    I'd like to acknowledge his contribution as my inspiration (even
    though the CalculatedVariables are designed entirely from scratch
    and using different technologies).<br>
    <h2>Rationale</h2>
    <p>A quasar-based OPC-UA server is based on a model of a system it
      is made for. This model is called a design. The model explains (in
      terms of quasar classes, variables etc) what sources and sinks on
      information the system can publish or digest.<br>
    </p>
    <p>Often it is practical to add supplementary sources of information
      - like Calculated Variables - on top of what the model already
      provides. The reasons for doing this are often the following:<br>
    </p>
    <ul>
      <li>the system already provides information which is expressed in
        quantities different than requested by users.<br>
        Example: an OPC-UA server is built for a device which measures
        period of a repetitive process, but the users prefer frequency
        instead.<br>
        Solution: a Calculated Variable might be added to the server
        with a simple reciprocal (y=1/x) formula to compute frequency in
        terms of period.</li>
      <li>the system already provides information but in another unit. <br>
      </li>
      <li>the system provides raw (e.g. uncalibrated) information.<br>
        Example: an OPC-UA server publishes data from Analog to Digital
        Converter. This is raw information though.<br>
        Solution: a Calculated Variable might be added to provide for
        gain and offset calibration.</li>
      <li>similarly to the example above, the ADC might have the value
        from a conversion of e.g. a temperature sensor. A Calculated
        Variable might be attached with a formula that recomputes the
        ADC value (in volts) into temperature.</li>
    </ul>
    <h2>Design-based variables vs Calculated Variables<br>
    </h2>
    <table cellspacing="2" cellpadding="2" width="100%" border="1">
      <tbody>
        <tr>
          <td valign="top"><b>Aspect</b><b><br>
            </b></td>
          <td valign="top"><b>Design-based variable</b><b><br>
            </b><b>(cache-variable or source-variable)</b><br>
          </td>
          <td valign="top"><b>Calculated Variable</b><b><br>
            </b></td>
        </tr>
        <tr>
          <td valign="top">Instantiation<br>
          </td>
          <td valign="top">The variable always belongs to an object of a
            quasar class which is defined by the model (Design).<br>
            Therefore in fact it's the design which determines its type,
            behaviour, limitations etc.<br>
          </td>
          <td valign="top">The variable is defined in the configuration
            file which is loaded at runtime.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">Source of information<br>
          </td>
          <td valign="top">Comes from inside of the server, typically
            from user supplied Device logic. Any method available by C++
            programming can be used.<br>
          </td>
          <td valign="top">Is a result of an analytical expression
            evaluation. The inputs to the expression can be constants
            and other variables (including previously defined Calculated
            Variables).<br>
          </td>
        </tr>
        <tr>
          <td valign="top">Output type<br>
          </td>
          <td valign="top">Any supported by quasar, including arrays.<br>
          </td>
          <td valign="top">Double or boolean.<br>
          </td>
        </tr>
        <tr>
          <td valign="top">Adding new variable per quasar class requires
            recompilation?<br>
          </td>
          <td valign="top">Yes<br>
          </td>
          <td valign="top">No<br>
          </td>
        </tr>
      </tbody>
    </table>
    <h2>Feature list</h2>
    <table cellspacing="2" cellpadding="2" border="1">
      <tbody>
        <tr>
          <td valign="top"><b>Feature</b><br>
          </td>
          <td valign="top"><b>State</b><br>
          </td>
        </tr>
        <tr>
          <td valign="top">Supports all quasar numerical types<br>
          </td>
          <td valign="top">Yes<br>
          </td>
        </tr>
        <tr>
          <td valign="top">Formulas with N inputs<br>
          </td>
          <td valign="top">Yes<br>
          </td>
        </tr>
        <tr>
          <td valign="top">Good/Bad/WaitingForInitialData support<br>
          </td>
          <td valign="top">Yes<br>
          </td>
        </tr>
        <tr>
          <td valign="top">Separate formula for status evaluation<br>
          </td>
          <td valign="top">Yes<br>
          </td>
        </tr>
        <tr>
          <td valign="top">Support for delegated cache-variables<br>
          </td>
          <td valign="top">Yes<br>
          </td>
        </tr>
        <tr>
          <td valign="top">Tracing in separate LogIt component<br>
          </td>
          <td valign="top">Yes<br>
          </td>
        </tr>
        <tr>
          <td valign="top">open62541 compatibility<br>
          </td>
          <td valign="top">Yes<br>
          </td>
        </tr>
        <tr>
          <td valign="top">Initial value support<br>
          </td>
          <td valign="top">Yes<br>
          </td>
        </tr>
        <tr>
          <td valign="top">Evaluation as boolean<br>
          </td>
          <td valign="top">Yes<br>
          </td>
        </tr>
        <tr>
          <td valign="top">Atomic passing of value and status, thread
            safety<br>
          </td>
          <td valign="top">Yes<br>
          </td>
        </tr>
        <tr>
          <td valign="top">Optimizing out variables not used in any
            expression<br>
          </td>
          <td valign="top">Yes<br>
          </td>
        </tr>
        <tr>
          <td valign="top">Formula templates<br>
          </td>
          <td valign="top">Future<br>
          </td>
        </tr>
      </tbody>
    </table>
    <p><br>
    </p>
    <h2>Selection of expression parser</h2>
    <p>There exist many open-source parsers potentially suitable for the
      feature. At the time of writing, a good overview was present at <a
href="https://github.com/ArashPartow/math-parser-benchmark-project">https://github.com/ArashPartow/math-parser-benchmark-project</a>
      .<br>
    </p>
    <p>The author has evaluted three parsers from the list:<br>
      <br>
    </p>
    <ul>
      <li><a href="http://www.partow.net/programming/exprtk/">ExprTk</a><br>
        It made an excellent overall impression. However, due to very
        intensive use of templates, the compilation time has been
        significant (i.e. its inclusion would triple(!!) the whole
        compilation time of a simple quasar server). That unfavourable
        property has made the quasar team to look for another solution.</li>
      <li><a href="https://sourceforge.net/projects/atmsp/">ATMSP</a><br>
        The initial code review has shown that the parser uses
        setjmp()/longjmp() which has been considered unfavourable for
        quasar servers.</li>
      <li><a href="http://beltoforion.de/article.php?a=muparser">muParser</a><br>
        muParser demonstrated decent performance while it has all the
        features required by the Calculated Variables feature.<br>
      </li>
    </ul>
    <h2>Overview of feature implementation</h2>
    <p>An UML class diagram is presented below.<br>
    </p>
    <img src="CalculatedVariablesClassDiagram.png" alt="UML"
      height="765" width="1098"><br>
    <h2>Classes rationale</h2>
    <ul>
      <li>ChangeNotifyingVariable - can emit notifications whenever the
        variable changed value. Applicable to any data type. Can be used
        with multiple notification receivers. Can be used for
        applications different than CalculatedVariables.</li>
      <li>ParserVariable - stored current numeric variable value as a
        plain double type, and therefore can be coupled as a mu::Parser
        variable. (Sidenote: mu::Parser doesn't know anything about
        OPC-UA and without such arrangement it wouldn't know how to
        access a double from UaVariant, neither to know whether the
        value is correct, etc.).</li>
      <ul>
        <li>notifyingVariable - is the pointer to a
          ChangeNotifyingVariable which notifies this particular
          ParserVariable on Change,</li>
        <li>notifiedVariables - the list of all CalculatedVariables that
          use this particular ParserVariable in formulas.</li>
      </ul>
      <li>CalculatedVariable - it's the OPC-UA variable defined by a
        formula. It's a subclass of ChangeNotifyingVariable because its
        output can in turn be used as an input to another Calculated
        Variable (so it must be able to emit notifications on change).</li>
      <li>Engine - puts all things together. It supplies methods for
        usage in Configuration module:</li>
      <ul>
        <li>instantiateCalculatedVariable - called whenerver
          CalculatedVariable() entry is found in the config file,</li>
        <li>registerVariableForCalculatedVariables - called whenever any
          cache-variable of suitable design properties (numeric and
          scalar) is inserted into the OPC-UA address-space<br>
        </li>
      </ul>
    </ul>
    <h2>Overview of information flow</h2>
    <ol>
      <li>All cache-variables instantiated by quasar Configuration
        module are of ChangeNotifyingVariable type or its subclasses.<br>
      </li>
      <li>When quasar Configuration determines that given cache-variable
        variable looks suitable to be used as a formula input (i.e. is
        numeric and it's scalar), it would add a ChangeListener and a
        corresponding ParserVariable. The ChangeListener will (once
        potentially invoked in future) call setValue() on given
        ParserVariable. <br>
      </li>
      <li>When device logic or an OPC-UA client writes to a suitable
        cache-variable, the setValue() of ParserVariable bound to the
        cache-variable will be called. It will store the new value and
        status in corresponding fields and then call update() on
        relevant (i.e. those which use given parser variable as an
        input) CalculatedVariable variables. <br>
      </li>
    </ol>
    <h2>Synchronization, re-entrance, multi-threading<br>
    </h2>
    <p>The CalculatedVariables module is closely tied to the
      AddressSpace of a quasar-based server. <br>
      For instance, the recalculation of an associated calculated
      variable is done within the call to a setter of a variable that it
      depends on. <br>
    </p>
    <p>It must be emphasized that AddressSpace is brutally
      multi-threaded. At the same time, the following thread families
      would be doing work on AddressSpace objects:<br>
    </p>
    <ul>
      <li>sampling threads which sample current values of
        cache-variables to which any client subscribes. Those threads
        are run by chosen OPC-UA backend and their number is highly
        dependent on backend's configuration (i.e. ServerConfig.xml) as
        well as possibly on number of connected clients and the set of
        data they subscribe to.</li>
      <li>server's OPC-UA requests processing threads. Those threads are
        run by chosen OPC-UA backend and similarily to sampling threads,
        their number depends on many factors. Those threads process e.g.
        Write service requests, so that an OPC-UA client can write to
        given variable.</li>
      <li>device logic (or other user threads). Those threads are
        instantiated by server developers and configured by end-users.
        They typically push data to the address-space.</li>
    </ul>
    <br>
    In the context of Calculated Variables, there are two obvious
    critical section types:<br>
    <ul>
      <li>possible calls to variable setters of the same variable coming
        from different threads.<br>
        The worries here are the following:</li>
      <ul>
        <li>there might be a clash in storage of value and status, as
          both of them are necessary to perform the calculation and (to
          author's knowledge) such an assignment is never atomic by
          default. So a recalculation might take value stored by one
          thread and status from another, or on a 32-bit machine (since
          double is 64-bits) even take partially stored value.</li>
        <li>it's not entirely clear if calls to mu::Parser::Eval are
          re-entrant.</li>
      </ul>
      <li>possible concurrent calls from different threads to variable
        setters of different variables which are used in the same
        formula.<br>
        The worries here are the following:</li>
      <ul>
        <li>the parser might attempt to use the value when it is being
          assigned to (and that is not atomic)</li>
        <li>it's not entirely clear if calls to mu::Parser::Eval are
          re-entrant.</li>
      </ul>
    </ul>
    <p>Having analyzed the problem and trying to propose a guaranteed
      dead-lock free solution, the author proposes to form disjoint
      subgraphs of the calculation graph and synchronize per each
      subgraph.<br>
    </p>
    <p>Let's look at an example for which the calculation graph is like
      in the picture below.<br>
    </p>
    <img src="SynchronizationExample.png" alt="Synchronization example"
      height="364" width="614"><br>
    PV stands for ParserVariable, those are all variables that can be
    used as inputs in a CalculatedVariable formula.<br>
    CV stands for CalculatedVariable. Note that every CV is also a PV
    because the output of one formula can be used as an input to another
    formula.<br>
    <br>
    <h3>Case 1: ignore CV4 (violet node and arrows)</h3>
    Case 1 would happen if we defined the following Calculated Variables
    in the config file (the particular operators - e.g. addition,
    multiplication - do not matter):<br>
    <br>
    CV1 = PV1 + PV2<br>
    CV2 = CV1*PV3 + PV2<br>
    CV3 = 3.14 * PV4<br>
    <br>
    In this case the implementation will form two domains of mutual
    exclusion (called synchronizers):<br>
    <ul>
      <li>1st one, which will provide exclusive access to setters of
        PV1, PV2 and PV3 (e.g. if any thread would enter setter of any
        of {PV1, PV2, PV3} all other threads willing to do the same
        would need to wait)</li>
      <li>2nd one, which will provide exclusive access to setter od PV4</li>
    </ul>
    <p>PV5 would not get a synchronizer because it's output is not used
      by anything; in fact PV5 would be optimized out after the
      configuration process is finished.<br>
    </p>
    <h3>Case 2: CV4 is added</h3>
    Now let's add CV4 to the picture.<br>
    <br>
    This (apparently) small extension actually does change a lot in the
    multi-threading schema: now one mutual exclusion domain gets formed
    which covers all possible setters. <br>
    Though such a scenario is rather unlikely to be seen, server
    developers and users should be aware of this relation.<br>
    <br>
    <br>
    <p><br>
    </p>
    <ol>
    </ol>
  </body>
</html>
